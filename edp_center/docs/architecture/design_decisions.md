# EDP_AI 框架设计决策文档

## 📋 文档信息

- **版本**: 1.0
- **最后更新**: 2025-01-XX
- **维护者**: EDP 框架团队

本文档记录 EDP_AI 框架的重要设计决策，包括决策原因、权衡考虑和替代方案。

---

## 1. 架构设计决策

### 1.1 为什么选择四 KIT 架构？

**决策**: 将框架拆分为四个独立的 KIT（edp_dirkit, edp_configkit, edp_cmdkit, edp_flowkit）

**原因**:
1. **职责分离**: 每个 KIT 负责一个明确的领域，职责清晰
2. **独立开发**: 不同团队可以并行开发不同的 KIT
3. **易于测试**: 每个 KIT 可以独立测试
4. **易于维护**: 修改一个 KIT 不会影响其他 KIT
5. **可复用性**: KIT 可以在其他项目中复用

**权衡**:
- ✅ **优点**: 模块化、可维护、可扩展
- ⚠️ **缺点**: 需要管理模块间的依赖关系，可能增加一些复杂性

**替代方案**:
- **单体架构**: 所有功能在一个模块中（❌ 难以维护和扩展）
- **微服务架构**: 每个 KIT 作为独立服务（❌ 过度设计，增加部署复杂度）

**结论**: 四 KIT 架构在模块化和复杂度之间取得了良好的平衡。

---

### 1.2 为什么使用 WorkflowManager 作为统一接口？

**决策**: 通过 `WorkflowManager` 整合四个 KIT，提供统一的工作流管理接口

**原因**:
1. **简化使用**: 用户不需要了解四个 KIT 的内部实现
2. **统一接口**: 提供一致的 API，降低学习成本
3. **协调执行**: 统一管理工作流的执行流程
4. **错误处理**: 统一的错误处理和日志记录

**权衡**:
- ✅ **优点**: 简化用户使用，统一接口
- ⚠️ **缺点**: 增加了一层抽象，可能隐藏一些细节

**替代方案**:
- **直接使用 KIT**: 用户直接调用各个 KIT（❌ 使用复杂，需要了解内部实现）
- **服务层**: 引入服务层抽象（❌ 可能过度设计）

**结论**: `WorkflowManager` 提供了必要的抽象，同时保持了灵活性。

---

## 2. 配置管理决策

### 2.1 为什么使用多层级配置？

**决策**: 采用 common → project → user 的多层级配置结构

**原因**:
1. **配置复用**: 通用配置可以在多个项目中复用
2. **配置覆盖**: 项目特定配置可以覆盖通用配置
3. **用户定制**: 用户可以在不修改项目配置的情况下定制
4. **配置管理**: 便于统一管理和版本控制

**权衡**:
- ✅ **优点**: 灵活、可复用、易于管理
- ⚠️ **缺点**: 配置加载顺序需要明确，可能增加调试难度

**替代方案**:
- **单一配置**: 只有一个配置文件（❌ 难以复用，难以管理）
- **环境变量**: 使用环境变量（❌ 不适合复杂的配置结构）

**结论**: 多层级配置结构适合多项目、多用户的场景。

---

### 2.2 为什么支持 YAML 和 Tcl 两种配置格式？

**决策**: 同时支持 YAML 和 Tcl 配置文件

**原因**:
1. **用户习惯**: 不同用户可能偏好不同的配置格式
2. **灵活性**: YAML 适合简单配置，Tcl 适合复杂逻辑
3. **兼容性**: 支持现有 Tcl 配置文件的迁移
4. **动态配置**: Tcl 支持动态计算和条件逻辑

**权衡**:
- ✅ **优点**: 灵活、兼容性好
- ⚠️ **缺点**: 需要维护两套解析逻辑，增加复杂度

**替代方案**:
- **只支持 YAML**: 统一使用 YAML（❌ 失去 Tcl 的动态能力）
- **只支持 Tcl**: 统一使用 Tcl（❌ YAML 更易读易写）

**结论**: 支持两种格式提供了灵活性，同时保持了兼容性。

---

## 3. 脚本处理决策

### 3.1 为什么使用 #import source 而不是直接 source？

**决策**: 使用 `#import source` 指令，在生成时展开为 `source` 语句

**原因**:
1. **路径解析**: 可以在生成时解析相对路径为绝对路径
2. **依赖检查**: 可以在生成时检查文件是否存在
3. **路径统一**: 统一处理不同操作系统的路径格式
4. **调试友好**: 生成的脚本包含完整的绝对路径，便于调试

**权衡**:
- ✅ **优点**: 路径解析、依赖检查、调试友好
- ⚠️ **缺点**: 需要预处理步骤，生成的脚本可能较大

**替代方案**:
- **直接 source**: 在运行时直接 source（❌ 路径问题、依赖检查困难）
- **编译时展开**: 完全展开内容（❌ 失去模块化，难以维护）

**结论**: `#import source` 在灵活性和可维护性之间取得了平衡。

---

### 3.2 为什么移除 #import util 机制？

**决策**: 移除 `#import util` 机制，统一使用 `#import source`

**原因**:
1. **简化设计**: 减少一种导入机制，降低复杂度
2. **统一接口**: 所有导入都使用相同的方式
3. **易于理解**: 用户只需要学习一种导入方式
4. **减少维护**: 减少需要维护的代码

**权衡**:
- ✅ **优点**: 简化、统一、易于维护
- ⚠️ **缺点**: 失去了一些内容展开的能力（但可以通过其他方式实现）

**替代方案**:
- **保留两种机制**: 同时支持 `#import util` 和 `#import source`（❌ 增加复杂度）
- **只使用 util**: 统一使用 `#import util`（❌ 失去 source 的灵活性）

**结论**: 统一使用 `#import source` 简化了设计，同时保持了必要的功能。

---

## 4. Hooks 机制决策

### 4.1 为什么使用文件名作为 Hooks 标识？

**决策**: 使用文件名（如 `add_tie_cell.pre`）而不是 proc 名称作为 Hooks 标识

**原因**:
1. **简单直观**: 文件名直接对应文件，易于理解
2. **自动发现**: 可以通过文件名自动发现 Hooks
3. **统一命名**: 所有 Hooks 使用统一的命名规则
4. **易于管理**: 文件系统管理比配置管理更直观

**权衡**:
- ✅ **优点**: 简单、直观、易于管理
- ⚠️ **缺点**: 文件名变更需要同步更新

**替代方案**:
- **使用 proc 名称**: 通过 proc 名称标识（❌ 需要解析文件内容）
- **使用配置文件**: 在配置文件中定义 Hooks（❌ 增加配置复杂度）

**结论**: 文件名作为标识符简单直观，符合文件系统的自然组织方式。

---

### 4.2 为什么自动封装 Hooks 代码为 proc？

**决策**: 自动将 Hooks 中的散装代码封装为 proc

**原因**:
1. **一致性**: 与 sub_step proc 保持一致的结构
2. **Debug 模式**: 支持 Debug 模式的交互式执行
3. **作用域管理**: proc 提供清晰的作用域边界
4. **易于调试**: proc 可以单独调用和测试

**权衡**:
- ✅ **优点**: 一致性、支持 Debug、易于调试
- ⚠️ **缺点**: 用户需要理解 proc 的概念

**替代方案**:
- **直接插入代码**: 不封装，直接插入代码（❌ 难以支持 Debug 模式）
- **用户手动封装**: 要求用户手动写 proc（❌ 增加用户负担）

**结论**: 自动封装提供了更好的开发体验和调试支持。

---

## 5. Sub_steps 机制决策

### 5.1 为什么使用 dependency.yaml 定义 Sub_steps？

**决策**: 在 `dependency.yaml` 中定义 Sub_steps，而不是在代码中硬编码

**原因**:
1. **配置驱动**: 通过配置文件驱动，无需修改代码
2. **易于修改**: 用户可以轻松添加、删除、重排序 Sub_steps
3. **版本控制**: 配置文件可以纳入版本控制
4. **多环境支持**: 不同环境可以使用不同的配置

**权衡**:
- ✅ **优点**: 灵活、可配置、易于管理
- ⚠️ **缺点**: 需要解析配置文件，可能增加启动时间

**替代方案**:
- **代码中定义**: 在代码中硬编码 Sub_steps（❌ 不灵活，难以修改）
- **数据库存储**: 使用数据库存储（❌ 增加部署复杂度）

**结论**: 使用配置文件提供了灵活性和可维护性。

---

### 5.2 为什么在生成脚本时展开所有 Sub_steps？

**决策**: 在生成脚本时将所有 Sub_steps 的 proc 定义展开到脚本开头

**原因**:
1. **自包含**: 生成的脚本是自包含的，不依赖外部文件
2. **易于分发**: 可以单独分发生成的脚本
3. **调试友好**: 所有代码在一个文件中，便于调试
4. **性能**: 避免运行时查找和加载文件

**权衡**:
- ✅ **优点**: 自包含、易于分发、调试友好
- ⚠️ **缺点**: 生成的脚本可能较大

**替代方案**:
- **运行时加载**: 在运行时动态加载 Sub_steps（❌ 增加运行时复杂度）
- **部分展开**: 只展开部分 Sub_steps（❌ 增加复杂度）

**结论**: 完全展开提供了更好的可移植性和调试体验。

---

## 6. 错误处理决策

### 6.1 为什么使用统一的异常体系？

**决策**: 创建 `edp_common.exceptions` 统一异常体系

**原因**:
1. **一致性**: 所有错误使用统一的格式
2. **上下文信息**: 异常包含丰富的上下文信息
3. **用户友好**: 提供解决建议，改善用户体验
4. **日志记录**: 便于结构化日志记录

**权衡**:
- ✅ **优点**: 一致性、用户友好、便于日志记录
- ⚠️ **缺点**: 需要定义和维护异常类

**替代方案**:
- **使用标准异常**: 直接使用 Python 标准异常（❌ 缺少上下文和建议）
- **字符串错误**: 使用字符串表示错误（❌ 难以结构化处理）

**结论**: 统一的异常体系提供了更好的错误处理和用户体验。

---

### 6.2 为什么使用装饰器统一错误处理？

**决策**: 使用 `@handle_cli_error` 装饰器统一 CLI 命令的错误处理

**原因**:
1. **减少重复**: 避免在每个函数中重复 try-except 代码
2. **统一格式**: 所有错误使用统一的输出格式
3. **自动日志**: 错误自动记录到日志
4. **易于维护**: 错误处理逻辑集中管理

**权衡**:
- ✅ **优点**: 减少重复、统一格式、易于维护
- ⚠️ **缺点**: 可能隐藏一些错误处理的细节

**替代方案**:
- **手动处理**: 在每个函数中手动处理错误（❌ 代码重复）
- **中间件**: 使用中间件处理错误（❌ 可能过度设计）

**结论**: 装饰器提供了简洁的错误处理方式，同时保持了灵活性。

---

## 7. 性能优化决策

### 7.1 为什么实现文件搜索缓存？

**决策**: 在 `file_finder.py` 中实现文件搜索缓存

**原因**:
1. **性能提升**: 重复搜索相同文件时显著提升性能
2. **大型项目**: 在大型项目中效果明显
3. **简单实现**: 缓存实现相对简单
4. **自动失效**: 基于目录修改时间戳自动失效

**权衡**:
- ✅ **优点**: 性能提升明显，实现简单
- ⚠️ **缺点**: 需要管理缓存，可能占用内存

**替代方案**:
- **不缓存**: 每次都重新搜索（❌ 性能较差）
- **持久化缓存**: 使用文件系统缓存（❌ 增加复杂度）

**结论**: 内存缓存提供了良好的性能提升，同时保持了实现的简单性。

---

## 8. 目录结构决策

### 8.1 为什么统一目录命名（steps/sub_steps/helpers）？

**决策**: 将 `scripts/`、`proc/`、`util/` 统一重命名为 `steps/`、`sub_steps/`、`helpers/`

**原因**:
1. **语义清晰**: 新名称更清晰地表达目录的用途
2. **统一规范**: 所有 Flow 使用统一的目录结构
3. **易于理解**: 新用户更容易理解目录的作用
4. **避免混淆**: 避免与通用术语（如 `scripts`）混淆

**权衡**:
- ✅ **优点**: 语义清晰、统一规范、易于理解
- ⚠️ **缺点**: 需要迁移现有代码和文档

**替代方案**:
- **保持旧名称**: 继续使用旧名称（❌ 语义不够清晰）
- **向后兼容**: 同时支持新旧名称（❌ 增加维护负担）

**结论**: 统一命名提供了更好的可读性和可维护性。

---

## 9. Debug 模式决策

### 9.1 为什么 Debug 模式只包含 proc 定义？

**决策**: Debug 模式脚本只包含 proc 定义，不包含直接调用

**原因**:
1. **交互式执行**: `edp_run` 管理执行流程，支持交互式调试
2. **灵活性**: 用户可以控制执行顺序和跳过步骤
3. **一致性**: 与正常模式的 proc 定义保持一致
4. **易于调试**: 可以单独调用和测试 proc

**权衡**:
- ✅ **优点**: 交互式、灵活、易于调试
- ⚠️ **缺点**: 需要额外的执行管理工具（edp_run）

**替代方案**:
- **包含调用**: Debug 模式也包含直接调用（❌ 失去交互性）
- **完全分离**: Debug 模式使用完全不同的结构（❌ 难以维护）

**结论**: 只包含 proc 定义提供了最佳的调试体验。

---

## 10. 总结

### 10.1 核心设计原则

1. **模块化**: 职责清晰，易于维护和扩展
2. **配置驱动**: 通过配置文件驱动，减少代码修改
3. **用户友好**: 提供清晰的错误信息和解决建议
4. **可扩展性**: 通过 Hooks 机制支持用户自定义
5. **性能优化**: 在保持简单性的同时优化性能

### 10.2 设计权衡

大多数设计决策都在以下方面进行了权衡：
- **简单性 vs 灵活性**: 优先选择简单性，在必要时提供灵活性
- **性能 vs 可维护性**: 优先选择可维护性，在关键路径优化性能
- **统一性 vs 兼容性**: 优先选择统一性，在必要时保持兼容性

### 10.3 未来改进方向

1. **接口抽象**: 引入更抽象的接口层
2. **插件机制**: 支持插件化扩展
3. **异步执行**: 支持异步执行机制
4. **数据库存储**: 考虑使用数据库存储元数据

---

**文档维护**: 每次重大设计变更后，应更新此文档记录决策和原因。

