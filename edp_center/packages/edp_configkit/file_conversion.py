#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
File conversion functions for configkit.
Provides functions for converting between different file formats (YAML, Tcl).
"""

import os
import yaml
from tkinter import Tcl
from typing import Dict

from .dict_ops import merge_dict, files2dict
from .tcl_interp import dict2tclinterp, tclfiles2tclinterp, tclinterp2dict, _write_tcl_vars_to_file


def files2tclfile(*input_files: str, output_file: str, add_source_comments: bool = True) -> None:
    """
    Convert a mixed list of YAML and Tcl files to a single Tcl file.
    Files are processed in order, with each file's content written sequentially to the output file.

    Args:
        *input_files: One or more paths to YAML or Tcl files
        output_file: Path to the output Tcl file
        add_source_comments: Whether to add comments indicating the source file for each section

    Returns:
        None

    Raises:
        FileNotFoundError: If any of the input files doesn't exist
        ValueError: If no input files are provided
    """
    if not input_files:
        raise ValueError("At least one input file must be provided")

    # Open the output file for writing
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# Generated by configkit\n\n")

        # Process each input file sequentially
        for input_file in input_files:
            if not os.path.exists(input_file):
                raise FileNotFoundError(f"Input file not found: {input_file}")

            # Get the absolute path of the file
            abs_path = os.path.abspath(input_file)

            # Determine file type based on extension
            file_ext = os.path.splitext(input_file)[1].lower()

            # Add a comment indicating the source file
            if add_source_comments:
                f.write(f"\n# From {abs_path}\n")

            # Process based on file type
            if file_ext in ('.yaml', '.yml'):
                # Handle YAML file
                with open(input_file, 'r', encoding='utf-8') as yf:
                    yaml_dict = yaml.safe_load(yf)

                if not yaml_dict:  # Handle empty YAML files
                    f.write("# (Empty file - no variables defined)\n")
                    continue

                # Convert dictionary to Tcl interpreter
                interp = dict2tclinterp(yaml_dict)

                # Write all variables from this file
                _write_tcl_vars_to_file(interp, f)

            elif file_ext in ('.tcl', '.tk'):
                # Handle Tcl file
                # Create a new interpreter
                interp = Tcl()

                try:
                    # Source the Tcl file
                    interp.eval(f"source {{{input_file}}}")

                    # Write all variables from this interpreter
                    _write_tcl_vars_to_file(interp, f)

                except Exception as e:
                    f.write(f"# Error loading Tcl file: {str(e)}\n")
            else:
                # Unknown file type
                f.write(f"# Skipping file with unknown extension: {file_ext}\n")


def files2yamlfile(*input_files: str, output_file: str, mode: str = "auto") -> None:
    """
    Convert a mixed list of YAML and Tcl files to a single YAML file.
    Files are processed in order and merged into a single dictionary.

    Args:
        *input_files: One or more paths to YAML or Tcl files
        output_file: Path to the output YAML file
        mode: Conversion mode for Tcl values ("auto", "str", or "list")

    Returns:
        None

    Raises:
        FileNotFoundError: If any of the input files doesn't exist
        ValueError: If no input files are provided
    """
    # Convert files to dictionary
    result_dict = files2dict(*input_files, mode=mode)

    # Write the result dictionary to the output YAML file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# Generated by configkit\n")
        yaml.dump(result_dict, f, default_flow_style=False, sort_keys=False)


def tclfiles2yamlfile(*tcl_files: str, output_file: str, mode: str = "auto") -> None:
    """
    Convert one or more Tcl files to a YAML file.

    Args:
        *tcl_files: One or more paths to Tcl files
        output_file: Path to the output YAML file
        mode: Conversion mode for space-separated values without type information:
              - "auto": Use type information if available, otherwise make best guess
              - "str": Always treat space-separated values as strings
              - "list": Always convert space-separated values to lists

    Returns:
        None

    Raises:
        FileNotFoundError: If any of the Tcl files doesn't exist
    """
    # Load Tcl files into an interpreter
    interp = tclfiles2tclinterp(*tcl_files)

    # Convert interpreter to dictionary
    data = tclinterp2dict(interp, mode=mode)

    # Write dictionary to YAML file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# Generated by configkit\n")
        yaml.dump(data, f, default_flow_style=False, sort_keys=False)


def yamlfiles2tclfile(*yaml_files: str, output_file: str, add_source_comments: bool = True) -> None:
    """
    Convert one or more YAML files to a Tcl file.
    Each YAML file's content is written sequentially to the Tcl file with source comments.

    Args:
        *yaml_files: One or more paths to YAML files
        output_file: Path to the output Tcl file
        add_source_comments: Whether to add comments indicating the source file for each section

    Returns:
        None

    Raises:
        FileNotFoundError: If any of the YAML files doesn't exist
        yaml.YAMLError: If there's an error parsing any YAML file
    """
    if not yaml_files:
        raise ValueError("At least one YAML file must be provided")

    # Open the output file for writing
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("# Generated by configkit\n\n")

        # Process each YAML file sequentially
        for yaml_file in yaml_files:
            if not os.path.exists(yaml_file):
                raise FileNotFoundError(f"YAML file not found: {yaml_file}")

            # Get the absolute path of the file
            abs_path = os.path.abspath(yaml_file)

            # Load the YAML file
            with open(yaml_file, 'r', encoding='utf-8') as yf:
                yaml_dict = yaml.safe_load(yf)

            # Add a comment indicating the source file
            if add_source_comments:
                f.write(f"\n# From {abs_path}\n")

            if not yaml_dict:  # Handle empty YAML files
                f.write("# (Empty file - no variables defined)\n")
                continue

            # Convert dictionary to Tcl interpreter
            interp = dict2tclinterp(yaml_dict)

            # Write all variables from this file
            _write_tcl_vars_to_file(interp, f)

